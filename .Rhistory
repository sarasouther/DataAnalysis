aes(x = size, ymin = pred_lower, ymax = pred_upper),
fill = "skyblue",
alpha = 0.4
) +
geom_line(
data = surv_df,
inherit.aes = FALSE,
aes(x = size, y = pred_median),
linewidth = 1
) +
labs(
x = expression(bold(Size[t])),
y = expression(bold(Probability~of~survival))
) +
theme_pubr(base_size = 16)
boot_fec1 <- matrix(NA_real_, n_pred, n_boot)
for (i in seq_len(n_boot)) {
boot_data <- final_data[sample(nrow(final_data), replace = TRUE), ]
mod <- glm(fec1 ~ size + I(size^2), family = binomial(), data = boot_data)
p <- predict(mod, newdata = data.frame(size = size_seq), type = "response")
boot_fec1[, i] <- pmin(pmax(p, 0), 1)
}
fec1_df <- boot_ci(boot_fec1)
fec1_uncertainty_plot <- ggplot(final_data, aes(x = size, y = fec1)) +
geom_jitter(height = 0.05, alpha = 0.25) +
geom_ribbon(
data = fec1_df,
inherit.aes = FALSE,
aes(x = size, ymin = pred_lower, ymax = pred_upper),
fill = "plum",
alpha = 0.4
) +
geom_line(
data = fec1_df,
inherit.aes = FALSE,
aes(x = size, y = pred_median),
linewidth = 1
) +
labs(
x = expression(bold(Size[t])),
y = expression(bold(Probability~of~flowering))
) +
theme_pubr(base_size = 16)
boot_fec2 <- matrix(NA_real_, n_pred, n_boot)
for (i in seq_len(n_boot)) {
boot_data <- final_data[sample(nrow(final_data), replace = TRUE), ]
mod <- glm(fec2 ~ size + I(size^2), family = poisson(), data = boot_data)
boot_fec2[, i] <- predict(mod, newdata = data.frame(size = size_seq), type = "response")
}
fec2_df <- boot_ci(boot_fec2)
fec2_uncertainty_plot <- ggplot(final_data, aes(x = size, y = fec2)) +
geom_point(alpha = 0.25) +
geom_ribbon(
data = fec2_df,
inherit.aes = FALSE,
aes(x = size, ymin = pred_lower, ymax = pred_upper),
fill = "goldenrod",
alpha = 0.4
) +
geom_line(
data = fec2_df,
inherit.aes = FALSE,
aes(x = size, y = pred_median),
linewidth = 1
) +
labs(
x = expression(bold(Size[t])),
y = expression(bold(Seed~production))
) +
theme_pubr(base_size = 16)
boot_growth <- matrix(NA_real_, n_pred, n_boot)
for (i in seq_len(n_boot)) {
boot_data <- final_data[sample(nrow(final_data), replace = TRUE), ]
mod <- lm(sizeNext ~ size + I(size^2), data = boot_data)
boot_growth[, i] <- predict(mod, newdata = data.frame(size = size_seq))
}
growth_df <- boot_ci(boot_growth)
growth_uncertainty_plot <- ggplot(final_data, aes(x = size, y = sizeNext)) +
geom_point(alpha = 0.25) +
geom_ribbon(
data = growth_df,
inherit.aes = FALSE,
aes(x = size, ymin = pred_lower, ymax = pred_upper),
fill = "darkseagreen3",
alpha = 0.4
) +
geom_line(
data = growth_df,
inherit.aes = FALSE,
aes(x = size, y = pred_median),
linewidth = 1
) +
labs(
x = expression(bold(Size[t])),
y = expression(bold(Size[t+1]))
) +
theme_pubr(base_size = 16)
uncertainty_panel <- ggarrange(
surv_uncertainty_plot,
fec1_uncertainty_plot,
fec2_uncertainty_plot,
growth_uncertainty_plot,
labels = c("A", "B", "C", "D"),
ncol = 2, nrow = 2
)
ggsave(
filename = paste0(
"FinalAnalysisResults/vitalrate_uncertainty_",
species_name, "_", trans_years, ".png"
),
plot = uncertainty_panel,
width = 12,
height = 10,
dpi = 400
)
uncertainty_panel
#===============================================
#===============================================
#===============================================
# Model diagnostics
#===============================================
#===============================================
#===============================================
overdisp_fun <- function(model) {
rdf <- df.residual(model)
rp  <- residuals(model, type = "pearson")
Pearson.chisq <- sum(rp^2)
ratio <- Pearson.chisq / rdf
pval  <- pchisq(Pearson.chisq, df = rdf, lower.tail = FALSE)
c(chisq = Pearson.chisq, ratio = ratio, rdf = rdf, p = pval)
}
overdisp_fun(surv_mod)
overdisp_fun(repr_mod)
final_data %>%
mutate(
surv_hat = predict(surv_mod, type = "response"),
repr_hat = predict(repr_mod, type = "response")
) %>%
ggplot(aes(size, surv)) +
geom_point(alpha = 0.3) +
geom_line(aes(y = surv_hat), linewidth = 1) +
labs(title = "Survival model fit") +
theme_pubr()
eviction_P <- sum(P[P < 0 | !is.finite(P)], na.rm = TRUE)
eviction_F <- sum(F[F < 0 | !is.finite(F)], na.rm = TRUE)
c(P_eviction = eviction_P, F_eviction = eviction_F)
eviction_P <- sum(P[P < 0 | !is.finite(P)], na.rm = TRUE)
eviction_F <- sum(F[F < 0 | !is.finite(F)], na.rm = TRUE)
c(P_eviction = eviction_P, F_eviction = eviction_F)
# Boundary test
size_test <- seq(L, U, length.out = 200)
mu_test <- predict(grow_mod, newdata = data.frame(size = size_test))
plot(size_test, mu_test, type = "l")
abline(h = c(L, U), lty = 2)
# Output directory
out_dir <- "/Users/sks379/Desktop/SERDP IPMs"
overdisp_fun <- function(model) {
rdf <- df.residual(model)
rp  <- residuals(model, type = "pearson")
Pearson.chisq <- sum(rp^2, na.rm = TRUE)
ratio <- Pearson.chisq / rdf
pval  <- pchisq(Pearson.chisq, df = rdf, lower.tail = FALSE)
out <- c(chisq = Pearson.chisq, ratio = ratio, rdf = rdf, p = pval)
return(out)
}
od_surv <- overdisp_fun(surv_mod)
od_repr <- overdisp_fun(repr_mod)
cat("\n--- Overdispersion diagnostics (binomial GLMs) ---\n")
cat("Survival model (surv_mod):\n"); print(od_surv)
cat("Flowering model (repr_mod):\n"); print(od_repr)
interpret_overdisp <- function(od, model_name = "model") {
ratio <- unname(od["ratio"])
cat("\nInterpretation for", model_name, ":\n")
if (!is.finite(ratio)) {
cat("- Ratio is not finite; check model fit / residuals.\n")
return(invisible(NULL))
}
if (ratio <= 1.5) {
cat("- Ratio ≈ 1 (<= 1.5): overdispersion not a concern.\n")
} else if (ratio <= 2) {
cat("- Ratio in (1.5, 2]: moderate overdispersion.\n")
cat("  Procedure: refit with quasibinomial OR use robust SEs.\n")
cat("  Example (quasi): glm(..., family = quasibinomial())\n")
cat("  Example (robust): sandwich::vcovHC + lmtest::coeftest\n")
} else {
cat("- Ratio > 2: strong overdispersion.\n")
cat("  Procedure: prefer robust SEs or quasibinomial; also inspect\n")
cat("  influential points / missing predictors.\n")
}
}
interpret_overdisp(od_surv, "surv_mod")
interpret_overdisp(od_repr, "repr_mod")
stopifnot(exists("P"), exists("F"))
bad_P_n <- sum(!is.finite(P) | P < 0)
bad_F_n <- sum(!is.finite(F) | F < 0)
cat("\n--- Kernel sanity check (P, F) ---\n")
cat("Bad entries in P (non-finite or negative):", bad_P_n, "of", length(P), "\n")
cat("Bad entries in F (non-finite or negative):", bad_F_n, "of", length(F), "\n")
if (bad_P_n > 0 || bad_F_n > 0) {
cat("\nInterpretation:\n")
cat("- Found negative/non-finite values in kernels. This indicates a kernel evaluation\n")
cat("  problem (usually prediction overflow, SD=0, or recruit distribution issues).\n")
cat("Procedure:\n")
cat("  1) Re-check grow_sd and recr_sd_safe are finite and > 0.\n")
cat("  2) Confirm predictions are bounded (you already clamp survival).\n")
cat("  3) For fecundity: cap predicted mu (you already pmin(mu, 1e6)).\n")
cat("  4) If still present, print ranges:\n")
cat("     range(P, finite=TRUE); range(F, finite=TRUE)\n")
} else {
cat("Interpretation:\n")
cat("- No negative/non-finite entries in P or F: kernel evaluation is numerically stable.\n")
}
stopifnot(exists("L"), exists("U"))
size_test <- seq(L, U, length.out = 200)
mu_test <- predict(grow_mod, newdata = data.frame(size = size_test), type = "response")
cat("\n--- Growth boundary check ---\n")
cat("Range of predicted mu(sizeNext):\n")
print(range(mu_test, na.rm = TRUE))
cat("Domain bounds: L =", L, "U =", U, "\n")
# Quick numeric rule-of-thumb for "problematic" boundary behavior:
# If > ~5% of mu is outside [L, U], consider expanding the domain or revisiting growth model.
outside_frac <- mean(mu_test < L | mu_test > U, na.rm = TRUE)
cat("Fraction of mu outside [L, U]:", round(outside_frac, 3), "\n")
# Plot (visual diagnostic)
plot(size_test, mu_test, type = "l",
xlab = "Size_t", ylab = "Predicted mean Size_{t+1}",
main = "Growth boundary diagnostic: mu(sizeNext) vs domain")
abline(h = c(L, U), lty = 2)
if (is.finite(outside_frac) && outside_frac > 0.05) {
cat("\nInterpretation:\n")
cat("- >5% of predicted mean growth falls outside the domain.\n")
cat("Procedure options (choose one):\n")
cat("  A) Expand domain bounds (e.g., L - k*grow_sd, U + k*grow_sd; k=1–2)\n")
cat("  B) Revisit growth model form (e.g., remove quadratic if it explodes at edges)\n")
cat("  C) Keep eviction but acknowledge in Methods/Supplement that boundary eviction is non-trivial\n")
} else {
cat("\nInterpretation:\n")
cat("- Predicted mean growth largely stays within domain; eviction is unlikely to dominate.\n")
}
bookdown::render_book("index.Rmd")
library(readr)
url <- "https://drive.google.com/uc?export=download&id=1KDvCzj9-YzN1zDHdLutcpruYx5mpcEWH"
example1 <- read_csv(url)
knitr::kable(example1, caption="Sample Space", full_width = F, html_font = "Arial")
#factorial of 5 or 5!
factorial <- 5*4*3*2*1; factorial
factorialR <- factorial(5); factorialR
#remember that
factorial(0)
permutations = (factorial(4))/factorial(4-3); permutations
set.seed(226)  # for reproducibility
# Simulate a single experiment: 3 flips
one_trial_two_heads <- function() {
flips <- sample(c("H","T"), size = 3, replace = TRUE)
sum(flips == "H") == 2
}
# Repeat the experiment many times
n_trials <- 10000
results <- replicate(n_trials, one_trial_two_heads())
# Estimated probability from simulation
p_hat <- mean(results)
p_hat
p_theory <- 3/8
c(simulated = p_hat, theoretical = p_theory)
library(readr)
url <- "https://drive.google.com/uc?export=download&id=1KDvCzj9-YzN1zDHdLutcpruYx5mpcEWH"
example1 <- read_csv(url)
knitr::kable(example1, caption="Sample Space", full_width = F, html_font = "Arial")
library(readr)
url <- "https://drive.google.com/uc?export=download&id=1KDvCzj9-YzN1zDHdLutcpruYx5mpcEWH"
example1 <- read_csv(url)
knitr::kable(example1, caption="Sample Space", full_width = F, html_font = "Arial")
answer = 1/36; answer
set.seed(226)
trial_sizes <- c(10, 50, 100, 500, 1000, 5000, 10000)
p_estimates <- sapply(trial_sizes, function(n) {
mean(replicate(n, one_trial_two_heads()))
})
data.frame(
n_trials = trial_sizes,
estimated_probability = p_estimates,
theoretical_probability = p_theory
)
plot(trial_sizes, p_estimates, log = "x",
xlab = "Number of trials (log scale)",
ylab = "Estimated probability",
main = "Long-run frequency: simulation converges toward the true probability")
abline(h = p_theory, lty = 2)
set.seed(226)
roll_die <- function() sample(1:6, size = 1)
n_rolls <- 10000
rolls <- replicate(n_rolls, roll_die())
p_hat_6 <- mean(rolls == 6)
c(simulated = p_hat_6, theoretical = 1/6)
set.seed(226)
roll_sizes <- c(10, 50, 100, 500, 1000, 5000, 10000)
p6_estimates <- sapply(roll_sizes, function(n) {
rolls <- sample(1:6, size = n, replace = TRUE)
mean(rolls == 6)
})
data.frame(
n_rolls = roll_sizes,
estimated_probability = p6_estimates,
theoretical_probability = 1/6
)
#The sample space is all possible rolls
samplespace <- c(1, 2, 3, 4, 5, 6); samplespace
#We will use Boolean operators in R. They will return TRUE / FALSE statements.
#Below we tell R to look for odd numbers OR (indicated by line)
#numbers less than 4.
unionevent <- (samplespace%%2==1) | (samplespace < 4); unionevent
#If the conditions are satisfied, TRUE will be returned.
#If conditions are not met, FALSE will be returned.
#Now, let's calculate the probability using techniques that you
#have already seen above.
probunion <- 4/6; probunion
conditional <- (1/6) / (1/2)
conditional
bookdown::render_book("index.Rmd")
set.seed(226)
# Flip a coin many times and track the running proportion of heads
n_flips <- 2000
flips <- sample(c("H", "T"), size = n_flips, replace = TRUE)
running_proportion <- cumsum(flips == "H") / (1:n_flips)
plot(1:n_flips, running_proportion,
type = "l", col = "steelblue", lwd = 1.5,
xlab = "Number of flips",
ylab = "Proportion of heads",
main = "Probability stabilizes with more observations",
ylim = c(0, 1))
abline(h = 0.5, lty = 2, col = "firebrick")
text(n_flips * 0.8, 0.54, "True probability = 0.5", col = "firebrick", cex = 0.9)
# Simulated monitoring data
set.seed(42)
n_plants <- 200
survived <- sample(c(TRUE, FALSE), n_plants, replace = TRUE, prob = c(0.7, 0.3))
flowered <- ifelse(survived,
sample(c(TRUE, FALSE), sum(survived), replace = TRUE, prob = c(0.4, 0.6)),
FALSE)
plant_data <- data.frame(
survived = survived,
flowered = flowered
)
# Summarize the data
cat("Total plants tagged:", n_plants, "\n")
cat("Survived winter:", sum(survived), "\n")
cat("Flowered:", sum(flowered), "\n")
cat("Died and flowered:", sum(!survived & flowered), "(should be 0)\n")
# P(flowered): probability of flowering across ALL tagged plants
p_flower <- mean(plant_data$flowered)
cat("P(flowered) =", round(p_flower, 3), "\n")
# P(flowered | survived): probability of flowering GIVEN survival
p_flower_given_survived <- mean(plant_data$flowered[plant_data$survived])
cat("P(flowered | survived) =", round(p_flower_given_survived, 3), "\n")
# Two independent events: flipping two separate coins
p_heads_coin1 <- 0.5
p_heads_coin2 <- 0.5
p_both_heads <- p_heads_coin1 * p_heads_coin2
cat("P(heads on both coins) =", p_both_heads, "\n")
# Two dependent events: survival across years
p_survive_yr1 <- 0.70
p_survive_yr2_given_yr1 <- 0.85  # higher because survivors are healthier
p_survive_both <- p_survive_yr1 * p_survive_yr2_given_yr1
cat("P(survive both years) =", p_survive_both, "\n")
# Compare: if we INCORRECTLY assumed independence
p_survive_yr2_marginal <- 0.70  # ignoring dependence
p_survive_both_wrong <- p_survive_yr1 * p_survive_yr2_marginal
cat("P(survive both years), assuming independence =", p_survive_both_wrong, "\n")
cat("Error from assuming independence:",
round(p_survive_both - p_survive_both_wrong, 3), "\n")
set.seed(226)
# Simulate planting 50 seeds, 10000 times
n_seeds <- 50
p_germ <- 0.30
n_reps <- 10000
germination_counts <- rbinom(n_reps, size = n_seeds, prob = p_germ)
hist(germination_counts,
breaks = seq(-0.5, max(germination_counts) + 0.5, by = 1),
col = "lightgreen", border = "darkgreen",
xlab = "Number of seeds germinated (out of 50)",
ylab = "Frequency",
main = "Distribution of germination outcomes\n(p = 0.30, n = 50 seeds)")
abline(v = n_seeds * p_germ, lty = 2, lwd = 2, col = "firebrick")
text(n_seeds * p_germ + 3, n_reps * 0.12, "Expected: 15", col = "firebrick", cex = 0.9)
# Our observed data
treatment <- c(rep(1, 22), rep(0, 28))  # 22 germinated out of 50
control   <- c(rep(1, 13), rep(0, 37))  # 13 germinated out of 50
# Combine into one dataset
germinated <- c(treatment, control)
group <- c(rep("treatment", 50), rep("control", 50))
# Observed difference in germination rates
obs_diff <- mean(germinated[group == "treatment"]) - mean(germinated[group == "control"])
cat("Observed difference in germination rate:", obs_diff, "\n")
set.seed(226)
n_perms <- 10000
perm_diffs <- numeric(n_perms)
for (i in 1:n_perms) {
shuffled_group <- sample(group)  # randomly reassign labels
perm_diffs[i] <- mean(germinated[shuffled_group == "treatment"]) -
mean(germinated[shuffled_group == "control"])
}
# Plot the null distribution
hist(perm_diffs,
breaks = 40,
col = "grey80", border = "grey50",
xlab = "Difference in germination rate (treatment - control)",
ylab = "Frequency",
main = "Null distribution: what chance alone produces")
abline(v = obs_diff, col = "firebrick", lwd = 2, lty = 2)
abline(v = -obs_diff, col = "firebrick", lwd = 2, lty = 2)
text(obs_diff + 0.02, n_perms * 0.06, "Observed\ndifference",
col = "firebrick", cex = 0.85, adj = 0)
# Two-sided p-value: proportion of permutations with |difference| >= |observed|
p_value <- mean(abs(perm_diffs) >= abs(obs_diff))
cat("p-value:", p_value, "\n")
summary_df <- data.frame(
Concept = c("Null model",
"Null distribution",
"p-value"),
Definition = c("A probability model representing 'no effect'",
"The distribution of outcomes under the null model",
"The probability of observing a result as extreme as ours, if the null model were true"),
In_our_example = c("Treatment has no effect on germination",
"Histogram of differences from 10,000 random shuffles",
paste0(p_value, " of shuffled differences were as extreme as ours"))
)
knitr::kable(summary_df, col.names = c("Concept", "What it means", "In our example"),
caption = "The three components of a statistical test")
dist_table <- data.frame(
`Data Type` = c(
"Continuous",
"Continuous (positive, skewed)",
"Continuous (bounded 0\u20131)",
"Counts (integers \u2265 0)",
"Counts with overdispersion",
"Counts with many zeros",
"Binary outcomes (0/1)",
"Proportions from counts",
"Categorical (unordered)",
"Ordinal (ordered categories)",
"Time-to-event",
"Nonlinear continuous"
),
Distribution = c(
"Normal (Gaussian)",
"Gamma",
"Beta",
"Poisson",
"Negative Binomial",
"Zero-inflated Poisson / NB",
"Binomial (Bernoulli)",
"Binomial",
"Multinomial",
"Ordinal logistic",
"Exponential / Weibull",
"Non-normal, unknown"
),
Link = c(
"Identity",
"Log",
"Logit / log\u2013log",
"Log",
"Log",
"Log",
"Logit / probit",
"Logit",
"Logit",
"Logit / probit",
"Log",
"Identity or specialized"
),
`Ecological Example` = c(
"Do burned plots have taller seedlings?",
"Does fertilizer increase biomass (always > 0)?",
"What proportion of cover is bare soil?",
"Does precipitation affect pitfall-trapped insects?",
"Does nutrient addition affect flower counts (variance > mean)?",
"Do invasive grasses produce many zero seedling counts?",
"Does shade increase seedling survival probability?",
"What proportion of seeds germinate per treatment?",
"Do grazing treatments shift vegetation type frequencies?",
"Does grazing intensity affect seedling vigor ranks?",
"How long do seedlings survive under drought?",
"Is the relationship between age and growth curved?"
),
`Typical Models` = c(
"t-test, ANOVA, linear regression, LMM",
"Gamma GLM, Gamma GLMM",
"Beta regression, Beta GLMM",
"Poisson GLM, Poisson GLMM",
"Negative Binomial GLM, NB GLMM",
"ZIP / ZINB, hurdle models",
"Logistic regression, Binomial GLM/GLMM",
"Binomial GLM, logistic regression",
"Multinomial logistic, Chi-square",
"Proportional odds (CLM/CLMM)",
"Survival analysis, Cox regression",
"GAM, GAMM"
),
check.names = FALSE
)
if (requireNamespace("kableExtra", quietly = TRUE)) {
knitr::kable(dist_table,
caption = "Reference: Data types, distributions, and models commonly used in ecology. Bookmark this table\u2014we will return to it throughout the course.",
format = "html") |>
kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
full_width = TRUE, font_size = 13)
} else {
knitr::kable(dist_table,
caption = "Reference: Data types, distributions, and models commonly used in ecology. Bookmark this table\u2014we will return to it throughout the course.")
}
bookdown::render_book("index.Rmd")
