# -----------------------------
eig <- eigen(K)
lambda_dom <- Re(eig$values[1])
# Stable size distribution (right eigenvector)
w <- Re(eig$vectors[, 1])
w <- w / sum(w)
# Reproductive value (left eigenvector)
v <- Re(eigen(t(K))$vectors[, 1])
v <- v / sum(v * w)   # standard normalization
# -----------------------------
# 4) Sensitivity and elasticity matrices
# -----------------------------
sensitivity <- outer(v, w)
elasticity  <- (K / lambda_dom) * sensitivity
# Elasticity should sum to 1
stopifnot(abs(sum(elasticity) - 1) < 1e-6)
# -----------------------------
# 5) Save matrices
# -----------------------------
write.csv(
sensitivity,
paste0(
"FinalAnalysisResults/sensitivity_",
species_name, "_", population, "_", trans_years, ".csv"
),
row.names = FALSE
)
write.csv(
elasticity,
paste0(
"FinalAnalysisResults/elasticity_",
species_name, "_", population, "_", trans_years, ".csv"
),
row.names = FALSE
)
# -----------------------------
# 6) Convert matrices to long format for plotting
# -----------------------------
elas_df <- as.data.frame(as.table(elasticity))
colnames(elas_df) <- c("from", "to", "value")
elas_df$from_size <- size_axis[elas_df$from]
elas_df$to_size   <- size_axis[elas_df$to]
# -----------------------------
# 7) Elasticity row sums (importance of size at time t)
# -----------------------------
elas_row <- rowSums(elasticity)
row_df <- tibble(
size = size_axis,
elasticity_sum = elas_row
)
# (A) Elasticity heatmap
elas_plot <- ggplot(
elas_df,
aes(x = from_size, y = to_size, fill = value)
) +
geom_tile() +
scale_fill_viridis_c(
name = "Elasticity",
labels = scales::label_number(accuracy = 0.001)
) +
labs(
x = "Size at time t",
y = "Size at time t+1",
title = "Elasticity matrix"
) +
theme_pubr(base_size = 14)
# (B) Elasticity row sums
row_plot <- ggplot(
row_df,
aes(x = size, y = elasticity_sum)
) +
geom_line(linewidth = 1.2, color = "steelblue") +
labs(
x = "Size at time t",
y = "Summed elasticity",
title = "Elasticity by size class"
) +
theme_pubr(base_size = 14)
# Combine panels
combo_plot <- ggarrange(
elas_plot, row_plot,
labels = c("A", "B"),
ncol = 2
)
# -----------------------------
# 9) Save figure (with population in filename)
# -----------------------------
ggsave(
filename = paste0(
"FinalAnalysisResults/elasticity_",
species_name, "_", population, "_", trans_years, ".png"
),
plot = combo_plot,
width = 12,
height = 6,
dpi = 400
)
# Step 1: Create a sequence of sizes over which to predict
size_seq <- seq(min(final_data$size, na.rm = TRUE),
max(final_data$size, na.rm = TRUE),
length.out = 100)
library(dplyr)
library(ggplot2)
library(ggpubr)
set.seed(42)
# ----------------------------------
# Common settings
# ----------------------------------
n_boot  <- 200
n_pred  <- 100
size_seq <- seq(
min(final_data$size, na.rm = TRUE),
max(final_data$size, na.rm = TRUE),
length.out = n_pred
)
boot_ci <- function(pred_mat) {
tibble(
size        = size_seq,
pred_median = apply(pred_mat, 1, median, na.rm = TRUE),
pred_lower  = apply(pred_mat, 1, quantile, probs = 0.025, na.rm = TRUE),
pred_upper  = apply(pred_mat, 1, quantile, probs = 0.975, na.rm = TRUE)
)
}
boot_surv <- matrix(NA, n_pred, n_boot)
for (i in 1:n_boot) {
boot_data <- final_data[sample(nrow(final_data), replace = TRUE), ]
mod <- glm(surv ~ size, family = binomial(), data = boot_data)
boot_surv[, i] <- predict(mod, newdata = data.frame(size = size_seq), type = "response")
}
surv_df <- boot_ci(boot_surv)
surv_uncertainty_plot <- ggplot(final_data, aes(size, surv)) +
geom_jitter(height = 0.05, alpha = 0.25) +
geom_ribbon(
data = surv_df,
aes(ymin = pred_lower, ymax = pred_upper),
fill = "skyblue", alpha = 0.4
) +
geom_line(
data = surv_df,
aes(y = pred_median),
linewidth = 1
) +
labs(
x = expression(bold(Size[t])),
y = expression(bold(Probability~of~survival))
) +
theme_pubr(base_size = 16)
boot_fec1 <- matrix(NA, n_pred, n_boot)
for (i in 1:n_boot) {
boot_data <- final_data[sample(nrow(final_data), replace = TRUE), ]
mod <- glm(fec1 ~ size + I(size^2), family = binomial(), data = boot_data)
boot_fec1[, i] <- predict(mod, newdata = data.frame(size = size_seq), type = "response")
}
fec1_df <- boot_ci(boot_fec1)
fec1_uncertainty_plot <- ggplot(final_data, aes(size, fec1)) +
geom_jitter(height = 0.05, alpha = 0.25) +
geom_ribbon(
data = fec1_df,
aes(ymin = pred_lower, ymax = pred_upper),
fill = "plum", alpha = 0.4
) +
geom_line(
data = fec1_df,
aes(y = pred_median),
linewidth = 1
) +
labs(
x = expression(bold(Size[t])),
y = expression(bold(Probability~of~flowering))
) +
theme_pubr(base_size = 16)
boot_fec2 <- matrix(NA, n_pred, n_boot)
for (i in 1:n_boot) {
boot_data <- final_data[sample(nrow(final_data), replace = TRUE), ]
mod <- glm(fec2 ~ size + I(size^2), family = poisson(), data = boot_data)
boot_fec2[, i] <- predict(mod, newdata = data.frame(size = size_seq), type = "response")
}
fec2_df <- boot_ci(boot_fec2)
fec2_uncertainty_plot <- ggplot(final_data, aes(size, fec2)) +
geom_point(alpha = 0.25) +
geom_ribbon(
data = fec2_df,
aes(ymin = pred_lower, ymax = pred_upper),
fill = "goldenrod", alpha = 0.4
) +
geom_line(
data = fec2_df,
aes(y = pred_median),
linewidth = 1
) +
labs(
x = expression(bold(Size[t])),
y = expression(bold(Seed~production))
) +
theme_pubr(base_size = 16)
boot_growth <- matrix(NA, n_pred, n_boot)
for (i in 1:n_boot) {
boot_data <- final_data[sample(nrow(final_data), replace = TRUE), ]
mod <- lm(sizeNext ~ size + I(size^2), data = boot_data)
boot_growth[, i] <- predict(mod, newdata = data.frame(size = size_seq))
}
growth_df <- boot_ci(boot_growth)
growth_uncertainty_plot <- ggplot(final_data, aes(size, sizeNext)) +
geom_point(alpha = 0.25) +
geom_ribbon(
data = growth_df,
aes(ymin = pred_lower, ymax = pred_upper),
fill = "darkseagreen3", alpha = 0.4
) +
geom_line(
data = growth_df,
aes(y = pred_median),
linewidth = 1
) +
labs(
x = expression(bold(Size[t])),
y = expression(bold(Size[t+1]))
) +
theme_pubr(base_size = 16)
uncertainty_panel <- ggarrange(
surv_uncertainty_plot,
fec1_uncertainty_plot,
fec2_uncertainty_plot,
growth_uncertainty_plot,
labels = c("A", "B", "C", "D"),
ncol = 2, nrow = 2
)
ggsave(
filename = paste0(
"FinalAnalysisResults/vitalrate_uncertainty_",
species_name, "_", trans_years, ".png"
),
plot = uncertainty_panel,
width = 12,
height = 10,
dpi = 400
)
library(dplyr)
library(ggplot2)
library(ggpubr)
library(tibble)
set.seed(42)
# ----------------------------------
# Common settings
# ----------------------------------
n_boot <- 200
n_pred <- 100
size_seq <- seq(
min(final_data$size, na.rm = TRUE),
max(final_data$size, na.rm = TRUE),
length.out = n_pred
)
boot_ci <- function(pred_mat) {
tibble(
size        = size_seq,
pred_median = apply(pred_mat, 1, median, na.rm = TRUE),
pred_lower  = apply(pred_mat, 1, quantile, probs = 0.025, na.rm = TRUE),
pred_upper  = apply(pred_mat, 1, quantile, probs = 0.975, na.rm = TRUE)
)
}
boot_surv <- matrix(NA_real_, n_pred, n_boot)
for (i in seq_len(n_boot)) {
boot_data <- final_data[sample(nrow(final_data), replace = TRUE), ]
mod <- glm(surv ~ size, family = binomial(), data = boot_data)
p <- predict(mod, newdata = data.frame(size = size_seq), type = "response")
boot_surv[, i] <- pmin(pmax(p, 0), 1)   # clamp
}
surv_df <- boot_ci(boot_surv)
surv_uncertainty_plot <- ggplot(final_data, aes(x = size, y = surv)) +
geom_jitter(height = 0.05, alpha = 0.25) +
geom_ribbon(
data = surv_df,
inherit.aes = FALSE,
aes(x = size, ymin = pred_lower, ymax = pred_upper),
fill = "skyblue",
alpha = 0.4
) +
geom_line(
data = surv_df,
inherit.aes = FALSE,
aes(x = size, y = pred_median),
linewidth = 1
) +
labs(
x = expression(bold(Size[t])),
y = expression(bold(Probability~of~survival))
) +
theme_pubr(base_size = 16)
boot_fec1 <- matrix(NA_real_, n_pred, n_boot)
for (i in seq_len(n_boot)) {
boot_data <- final_data[sample(nrow(final_data), replace = TRUE), ]
mod <- glm(fec1 ~ size + I(size^2), family = binomial(), data = boot_data)
p <- predict(mod, newdata = data.frame(size = size_seq), type = "response")
boot_fec1[, i] <- pmin(pmax(p, 0), 1)
}
fec1_df <- boot_ci(boot_fec1)
fec1_uncertainty_plot <- ggplot(final_data, aes(x = size, y = fec1)) +
geom_jitter(height = 0.05, alpha = 0.25) +
geom_ribbon(
data = fec1_df,
inherit.aes = FALSE,
aes(x = size, ymin = pred_lower, ymax = pred_upper),
fill = "plum",
alpha = 0.4
) +
geom_line(
data = fec1_df,
inherit.aes = FALSE,
aes(x = size, y = pred_median),
linewidth = 1
) +
labs(
x = expression(bold(Size[t])),
y = expression(bold(Probability~of~flowering))
) +
theme_pubr(base_size = 16)
boot_fec2 <- matrix(NA_real_, n_pred, n_boot)
for (i in seq_len(n_boot)) {
boot_data <- final_data[sample(nrow(final_data), replace = TRUE), ]
mod <- glm(fec2 ~ size + I(size^2), family = poisson(), data = boot_data)
boot_fec2[, i] <- predict(mod, newdata = data.frame(size = size_seq), type = "response")
}
fec2_df <- boot_ci(boot_fec2)
fec2_uncertainty_plot <- ggplot(final_data, aes(x = size, y = fec2)) +
geom_point(alpha = 0.25) +
geom_ribbon(
data = fec2_df,
inherit.aes = FALSE,
aes(x = size, ymin = pred_lower, ymax = pred_upper),
fill = "goldenrod",
alpha = 0.4
) +
geom_line(
data = fec2_df,
inherit.aes = FALSE,
aes(x = size, y = pred_median),
linewidth = 1
) +
labs(
x = expression(bold(Size[t])),
y = expression(bold(Seed~production))
) +
theme_pubr(base_size = 16)
boot_growth <- matrix(NA_real_, n_pred, n_boot)
for (i in seq_len(n_boot)) {
boot_data <- final_data[sample(nrow(final_data), replace = TRUE), ]
mod <- lm(sizeNext ~ size + I(size^2), data = boot_data)
boot_growth[, i] <- predict(mod, newdata = data.frame(size = size_seq))
}
growth_df <- boot_ci(boot_growth)
growth_uncertainty_plot <- ggplot(final_data, aes(x = size, y = sizeNext)) +
geom_point(alpha = 0.25) +
geom_ribbon(
data = growth_df,
inherit.aes = FALSE,
aes(x = size, ymin = pred_lower, ymax = pred_upper),
fill = "darkseagreen3",
alpha = 0.4
) +
geom_line(
data = growth_df,
inherit.aes = FALSE,
aes(x = size, y = pred_median),
linewidth = 1
) +
labs(
x = expression(bold(Size[t])),
y = expression(bold(Size[t+1]))
) +
theme_pubr(base_size = 16)
uncertainty_panel <- ggarrange(
surv_uncertainty_plot,
fec1_uncertainty_plot,
fec2_uncertainty_plot,
growth_uncertainty_plot,
labels = c("A", "B", "C", "D"),
ncol = 2, nrow = 2
)
ggsave(
filename = paste0(
"FinalAnalysisResults/vitalrate_uncertainty_",
species_name, "_", trans_years, ".png"
),
plot = uncertainty_panel,
width = 12,
height = 10,
dpi = 400
)
uncertainty_panel
#===============================================
#===============================================
#===============================================
# Model diagnostics
#===============================================
#===============================================
#===============================================
overdisp_fun <- function(model) {
rdf <- df.residual(model)
rp  <- residuals(model, type = "pearson")
Pearson.chisq <- sum(rp^2)
ratio <- Pearson.chisq / rdf
pval  <- pchisq(Pearson.chisq, df = rdf, lower.tail = FALSE)
c(chisq = Pearson.chisq, ratio = ratio, rdf = rdf, p = pval)
}
overdisp_fun(surv_mod)
overdisp_fun(repr_mod)
final_data %>%
mutate(
surv_hat = predict(surv_mod, type = "response"),
repr_hat = predict(repr_mod, type = "response")
) %>%
ggplot(aes(size, surv)) +
geom_point(alpha = 0.3) +
geom_line(aes(y = surv_hat), linewidth = 1) +
labs(title = "Survival model fit") +
theme_pubr()
eviction_P <- sum(P[P < 0 | !is.finite(P)], na.rm = TRUE)
eviction_F <- sum(F[F < 0 | !is.finite(F)], na.rm = TRUE)
c(P_eviction = eviction_P, F_eviction = eviction_F)
eviction_P <- sum(P[P < 0 | !is.finite(P)], na.rm = TRUE)
eviction_F <- sum(F[F < 0 | !is.finite(F)], na.rm = TRUE)
c(P_eviction = eviction_P, F_eviction = eviction_F)
# Boundary test
size_test <- seq(L, U, length.out = 200)
mu_test <- predict(grow_mod, newdata = data.frame(size = size_test))
plot(size_test, mu_test, type = "l")
abline(h = c(L, U), lty = 2)
# Output directory
out_dir <- "/Users/sks379/Desktop/SERDP IPMs"
overdisp_fun <- function(model) {
rdf <- df.residual(model)
rp  <- residuals(model, type = "pearson")
Pearson.chisq <- sum(rp^2, na.rm = TRUE)
ratio <- Pearson.chisq / rdf
pval  <- pchisq(Pearson.chisq, df = rdf, lower.tail = FALSE)
out <- c(chisq = Pearson.chisq, ratio = ratio, rdf = rdf, p = pval)
return(out)
}
od_surv <- overdisp_fun(surv_mod)
od_repr <- overdisp_fun(repr_mod)
cat("\n--- Overdispersion diagnostics (binomial GLMs) ---\n")
cat("Survival model (surv_mod):\n"); print(od_surv)
cat("Flowering model (repr_mod):\n"); print(od_repr)
interpret_overdisp <- function(od, model_name = "model") {
ratio <- unname(od["ratio"])
cat("\nInterpretation for", model_name, ":\n")
if (!is.finite(ratio)) {
cat("- Ratio is not finite; check model fit / residuals.\n")
return(invisible(NULL))
}
if (ratio <= 1.5) {
cat("- Ratio ≈ 1 (<= 1.5): overdispersion not a concern.\n")
} else if (ratio <= 2) {
cat("- Ratio in (1.5, 2]: moderate overdispersion.\n")
cat("  Procedure: refit with quasibinomial OR use robust SEs.\n")
cat("  Example (quasi): glm(..., family = quasibinomial())\n")
cat("  Example (robust): sandwich::vcovHC + lmtest::coeftest\n")
} else {
cat("- Ratio > 2: strong overdispersion.\n")
cat("  Procedure: prefer robust SEs or quasibinomial; also inspect\n")
cat("  influential points / missing predictors.\n")
}
}
interpret_overdisp(od_surv, "surv_mod")
interpret_overdisp(od_repr, "repr_mod")
stopifnot(exists("P"), exists("F"))
bad_P_n <- sum(!is.finite(P) | P < 0)
bad_F_n <- sum(!is.finite(F) | F < 0)
cat("\n--- Kernel sanity check (P, F) ---\n")
cat("Bad entries in P (non-finite or negative):", bad_P_n, "of", length(P), "\n")
cat("Bad entries in F (non-finite or negative):", bad_F_n, "of", length(F), "\n")
if (bad_P_n > 0 || bad_F_n > 0) {
cat("\nInterpretation:\n")
cat("- Found negative/non-finite values in kernels. This indicates a kernel evaluation\n")
cat("  problem (usually prediction overflow, SD=0, or recruit distribution issues).\n")
cat("Procedure:\n")
cat("  1) Re-check grow_sd and recr_sd_safe are finite and > 0.\n")
cat("  2) Confirm predictions are bounded (you already clamp survival).\n")
cat("  3) For fecundity: cap predicted mu (you already pmin(mu, 1e6)).\n")
cat("  4) If still present, print ranges:\n")
cat("     range(P, finite=TRUE); range(F, finite=TRUE)\n")
} else {
cat("Interpretation:\n")
cat("- No negative/non-finite entries in P or F: kernel evaluation is numerically stable.\n")
}
stopifnot(exists("L"), exists("U"))
size_test <- seq(L, U, length.out = 200)
mu_test <- predict(grow_mod, newdata = data.frame(size = size_test), type = "response")
cat("\n--- Growth boundary check ---\n")
cat("Range of predicted mu(sizeNext):\n")
print(range(mu_test, na.rm = TRUE))
cat("Domain bounds: L =", L, "U =", U, "\n")
# Quick numeric rule-of-thumb for "problematic" boundary behavior:
# If > ~5% of mu is outside [L, U], consider expanding the domain or revisiting growth model.
outside_frac <- mean(mu_test < L | mu_test > U, na.rm = TRUE)
cat("Fraction of mu outside [L, U]:", round(outside_frac, 3), "\n")
# Plot (visual diagnostic)
plot(size_test, mu_test, type = "l",
xlab = "Size_t", ylab = "Predicted mean Size_{t+1}",
main = "Growth boundary diagnostic: mu(sizeNext) vs domain")
abline(h = c(L, U), lty = 2)
if (is.finite(outside_frac) && outside_frac > 0.05) {
cat("\nInterpretation:\n")
cat("- >5% of predicted mean growth falls outside the domain.\n")
cat("Procedure options (choose one):\n")
cat("  A) Expand domain bounds (e.g., L - k*grow_sd, U + k*grow_sd; k=1–2)\n")
cat("  B) Revisit growth model form (e.g., remove quadratic if it explodes at edges)\n")
cat("  C) Keep eviction but acknowledge in Methods/Supplement that boundary eviction is non-trivial\n")
} else {
cat("\nInterpretation:\n")
cat("- Predicted mean growth largely stays within domain; eviction is unlikely to dominate.\n")
}
